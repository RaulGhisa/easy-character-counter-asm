TITLE EASY CHARACTER COUNTERS
IF1           
INCLUDE C:\TASM\MYLIB.MAC
ENDIF 

STACKPRJ SEGMENT PARA 'STACK' 			 
	DB 64 DUP ('STACK') 
STACKPRJ ENDS 

PRJDATA SEGMENT PARA 'DATA'
	SHOW_LETTERS		DB '<>   SHOW LETTERS  $'
	SHOW_LETTERS_LEN	DW $-SHOW_LETTERS			
	SHOW_SYMBOLS		DB '<>   SHOW SYMBOLS $'
	SHOW_SYMBOLS_LEN	DW $-SHOW_LETTERS
	SHOW_DIGITS			DB '<>   SHOW DIGITS   <>$'
	SHOW_DIGITS_LEN		DW $-SHOW_LETTERS
	SHOW_TOTAL			DB 'TOTAL: $'
	SHOW_TOTAL_LEN		DB $-SHOW_TOTAL
	TOTAL				DW 00H
	LETTERS				DB 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
	LETTERS_LEN			DW $-LETTERS
	SYMBOLS				DB '!"#$%&'
						DB 27H
						DB '()*+,-./:;<=>?@[\]^_`{|}~'
	SYMBOLS_LEN			DW $-SYMBOLS
	DIGITS				DB '0123456789'
	DIGITS_LEN			DW 0AH
	COUNTERS_TYPE		DB 01H
	CURSOR_POSITION		DW 0100H
	ASCII  				DW 96 DUP(0)
	TAB    				DB '0123456789ABCDEF'
	CURSOR_UPPER_BOUND	DW 0000H 
	CURSOR_LOWER_BOUND  DW 114FH
	LINE  				DB 1E0H DUP(' '), '$'
	FONT_COLOR			DB 'CHOOSE A FONT COLOR: $'
	FONT_OPTIONS		DB '1. NICE BLUE 2. GREEN 3. LIGHT BLUE 4. RED 5. PINK 6. ORANGE 7. GREY 8. YELLOW$'
	BACKGROUND_COLOR	DB 'CHOOSE A BACKGROUND COLOR: $'
	BACKGROUND_OPTIONS	DB '1. NICE BLUE 2. GREEN 3. LIGHT BLUE 4. RED 5. PINK 6. ORANGE 7. GREY$'
	OPTION_SELECT		DB 1EH
PRJDATA ENDS

CODE SEGMENT PARA 'CODE'
	START PROC FAR
	ASSUME CS:CODE, DS:PRJDATA , SS:STACKPRJ

		PUSH DS
		XOR AX, AX
		PUSH AX
		MOV AX, PRJDATA
		MOV DS, AX
				
		SET_DISPLAY OPTION_SELECT		;SET THE DEFAULT DISPLAY SETTING
		CALL READ_OPTIONS				;CALL FONT AND BACKGROUND SETTING PROCEDURE
		SET_DISPLAY OPTION_SELECT		;SET THE USER DISPLAY SETTING
			
		MOV AX, CURSOR_LOWER_BOUND				
		MOV AL, BYTE PTR SHOW_DIGITS_LEN[00H]	;SET THE COUNTERS VIEW BOUNDS
		PUSH AX
		MOV AL, BYTE PTR SHOW_SYMBOLS_LEN[00H]
		PUSH AX
		MOV AL, BYTE PTR SHOW_LETTERS_LEN[00H]
		PUSH AX
		MOV AL, 00H
		PUSH AX
		
		SET_BUTTON SHOW_LETTERS			;SET THE COUNTERS VIEW
		SET_BUTTON SHOW_SYMBOLS
		SET_BUTTON SHOW_DIGITS	
		SET_BUTTON SHOW_TOTAL
		
		SET_CURSOR CURSOR_UPPER_BOUND		;SET THE CURSOR ON THE UPPER BOUND
		
		JMP COUNTERS		;JUMP TO DISPLAY THE DEFAULT COUNTERS

	READ : 					;READ CHARATERS
		MOV AH, 00H
		INT 16H
		CMP AL, 1BH
			JE ESCAPE_NEAR
		CMP AH, 48H
			JE UP_ARROW
		CMP AH, 4BH
			JE LEFT_ARROW
		CMP AH, 4DH
			JE RIGHT_ARROW
		CMP AH, 50H
			JE DOWN_ARROW
		CMP AL, 0DH
			JE RETURN_FOUND
		CMP AL, 08H
			JE BACKSPACE_NEAR
		CMP AL, ' '
			JL READ 			;CHARACTER NOT FOUND
		CMP AL, '~'
			JLE DISPLAY_NEAR	;CHARACTER FOUND
		JMP READ				;CATCH ALL THE RESIDUE

		DISPLAY_NEAR :			;FAR JUMPS
			JMP DISPLAY_PHASE
			
		ESCAPE_NEAR :
			JMP ESCAPE
			
		BACKSPACE_NEAR :
			JMP BACKSPACE_FOUND
			
		UP_ARROW :
			GET_CURSOR

			CMP DH, BYTE PTR CURSOR_UPPER_BOUND[01H] 	;CHECK IF THE CURSOR IS BETWEEN THE LIMITS
				JE READ
			
			MOV AH, 02H  	
			SUB DH, 01H		;MOVE CURSOR UP
			INT 10H

			JMP READ

		DOWN_ARROW :
			GET_CURSOR

			CMP DH, BYTE PTR CURSOR_LOWER_BOUND[01H]	;CHECK IF THE CURSOR IS BETWEEN THE LIMITS
				JGE READ
				
			MOV AH, 02H		
			ADD DH, 01H		;MOVE CURSOR DOWN
			INT 10H

			JMP READ

		RIGHT_ARROW :
			GET_CURSOR
			
			CMP DL, 4FH
				JE READ
		
			MOV AH, 02H  
			ADD DL, 01H		;MOVE CURSOR RIGHT
			INT 10H

			JMP READ

		LEFT_ARROW :
			GET_CURSOR
			
			CMP DL, 00H
				JE READ

			MOV AH, 02H  
			SUB DL, 01H		;MOVE CURSOR LEFT
			INT 10H
			
			JMP READ
		
		RETURN_FOUND :
			
			GET_CURSOR
			CMP DH, BYTE PTR CURSOR_LOWER_BOUND[01H]		;CHECK IF THE CURSOR IS ABOVE THE VIEWS SELECT
					JL EXIT_BUTTON_SELECT
				CMP DL, BYTE PTR SHOW_LETTERS_LEN[00H]		;CHECK IF LETTER COUNTER 
					JLE SHOW_LETTERS_COMMAND
				CMP DL, BYTE PTR SHOW_SYMBOLS_LEN[00H]		;CHECK IF SYMBOL COUNTER
					JLE SHOW_SYMBOLS_COMMAND
				CMP DL, BYTE PTR SHOW_DIGITS_LEN[00H]		;CHECK IF DECIMAL COUNTER
					JLE SHOW_DIGITS_COMMAND
			
			SHOW_LETTERS_COMMAND :			;SET THE CORRESPONDING VIEW SELECT IN COUNTERS_TYPE VARIABLE
				MOV COUNTERS_TYPE, 01H
				JMP COUNTERS
				
			SHOW_SYMBOLS_COMMAND :
				MOV COUNTERS_TYPE, 02H
				JMP COUNTERS
				
			SHOW_DIGITS_COMMAND :
				MOV COUNTERS_TYPE, 03H
				JMP COUNTERS
			
			EXIT_BUTTON_SELECT :
			
			NEWLINE

			JMP READ
	
		BACKSPACE_FOUND :
			DISPLAY_CHAR 08H
			
			MOV BH, 00H			;RECOGNIZE SYMBOL FROM CONSOLE IN ORDER TO BE DECREMENTED
			MOV AH, 08H	
			INT 10H
			
			CALL DECREMENT		;DECREMENT THE CORRESPONDING CHARACTER

			DISPLAY_CHAR ' '
			DISPLAY_CHAR 08H
			
			GET_CURSOR
			MOV CURSOR_POSITION, DX		;SAVE CURSOR ON CURSOR_POSITION VARIABLE

			JMP COUNTERS
			
		DISPLAY_PHASE :
			GET_CURSOR
			CMP DH, BYTE PTR CURSOR_LOWER_BOUND[01H]	;CHECK IF THE CURSOR IS ABOVE THE VIEWS SELECT
				JL CONTINUE_DISPLAY						;SO CHARACTERS CANNOT BE WRITTEN
			JMP READ
				
			CONTINUE_DISPLAY :
				
				OVERLAPPING :
					PUSH AX
					READ_CONSOLE_CHARACTER	;RECOGNIZE SYMBOL FROM CONSOLE IN ORDER TO BE DECREMENTED
					CALL DECREMENT		;DECREMENT THE CORRESPONDING CHARACTER
					POP AX
			
				NO_OVERLAPPING:
					DISPLAY_CHAR AL
					GET_CURSOR
					MOV CURSOR_POSITION, DX		;SAVE CURSOR POSITION		

		COUNTER_INCREMENT :		;INCREMENT THE SYMBOL COUNTER
			XOR AH, AH
			MOV SI, AX		
			SUB SI, ' '
			ADD SI, SI
			INC ASCII[SI]
			
		COUNTERS :
			
		CALL DISPLAY_COUNTERS

		SET_CURSOR CURSOR_POSITION		;RESTORE THE CURSOR AFTER UPDATING COUNTERS DISPLAY	
		
		JMP READ
		
	ESCAPE :			;EXIT THE APPLICATION
	SET_DISPLAY 1EH		;RESTORE DISPLAY SETTING
	MOV AH, 4CH
	INT 21H
		
	START ENDP
	
	PROC DISPLAY_COUNTERS
		
		PUSH AX
		PUSH CX
		PUSH DX
		PUSH SI
		
		SHOW_TOTAL_COMMAND :		;UPDATE THE TOTAL COUNTER
			CALL CHAR_SUM		
			SET_CURSOR 1148H
			MOV AX, TOTAL
			CALL TO_DECIMAL
		
		CMP COUNTERS_TYPE, 01H			;DECIDE WHAT COUNTER TO SHOW
			JE SHOW_LETTERS_COUNTER
		CMP COUNTERS_TYPE, 02H
			JE SHOW_SYMBOLS_COUNTER
		CMP COUNTERS_TYPE, 03H
			JE SHOW_DIGITS_COUNTER
			
		SHOW_LETTERS_COUNTER :
			MOV SI, OFFSET LETTERS
			MOV CX, LETTERS_LEN
			JMP EXIT_COUNTERS_SELECT
				
		SHOW_SYMBOLS_COUNTER :
			MOV SI, OFFSET SYMBOLS
			MOV CX, SYMBOLS_LEN
			JMP EXIT_COUNTERS_SELECT
				
		SHOW_DIGITS_COUNTER :
			MOV SI, OFFSET DIGITS
			MOV CX, DIGITS_LEN
			JMP EXIT_COUNTERS_SELECT
		
		EXIT_COUNTERS_SELECT :
		
		SET_CURSOR 1200H		;CURSOR ON 19th ROW	
		TYPE_STRING LINE
		SET_CURSOR 1200H
		
		MOV CH, CL				
		XOR CL, CL
			
		COUNTERS_LOOP :
			
			DISPLAY_CHAR [SI]	;SET THE TEMPLATE FOR ONE CHARACTER 
			DISPLAY_CHAR ':'		
			DISPLAY_CHAR ' '
			
			MOV AL, [SI]
			SUB AL, ' '
			XOR AH, AH
			MOV DI, AX
			ADD DI, DI
		
			MOV AX, ASCII[DI]
			PUSH CX
			CALL TO_DECIMAL		;HEX TO DEC
			POP CX
			
			DISPLAY_CHAR ' '
			
			INC SI				;INCREMENT STRING COUNTER	
			INC CL
			
			CMP CL, CH
				JGE EXIT_DISPLAY_COUNTERS
			JMP COUNTERS_LOOP

		EXIT_DISPLAY_COUNTERS :
		
		POP AX
		POP CX
		POP DX
		POP SI
		
	RET 
	
	DISPLAY_COUNTERS ENDP
	
	PROC TO_DECIMAL
		
		PUSH AX
		PUSH BX
		PUSH CX
		PUSH DX
		
		XOR CX, CX
		
		DIVISION :  
			XOR DX, DX
			MOV BX, 0AH
			DIV BX
			PUSH DX
			INC CX
			CMP CX, 04H
				JNE DIVISION
			
		DISPLAY_DIGIT : 
			POP DX
			ADD DX, '0'
			MOV AH, 02H
			INT 21H
			LOOP DISPLAY_DIGIT
			
		POP DX	
		POP CX
		POP BX
		POP AX
		
	RET
	
	TO_DECIMAL ENDP
	
	PROC CHAR_SUM		;SUM ALL THE COUNTERS
		
		PUSH AX
		PUSH CX
		PUSH SI
		
		MOV TOTAL, 00H
		MOV CX, 5FH
		MOV SI, OFFSET ASCII + 02H
		SUM :
			MOV AX, TOTAL
			ADD AX, [SI]
			MOV TOTAL, AX
			ADD SI, TYPE ASCII
			LOOP SUM
		
		POP SI
		POP CX
		POP AX
		
		RET
		
	CHAR_SUM ENDP
	
	PROC READ_OPTIONS		;FONT AND BACKGROUND PANEL
		
		PUSH AX
		PUSH BX
		
		SET_CURSOR 1100H
		
		NEWLINE
		TYPE_STRING BACKGROUND_COLOR
		NEWLINE
		TYPE_STRING BACKGROUND_OPTIONS
		NEWLINE

		MOV AH, 01H
		INT 21H
		
		CMP AL, 1BH				;CHECKS IF ESCAPE
			JE END_OPTION
		
		SUB AL, '0'
		MOV BL, AL
		
		NEWLINE
		TYPE_STRING FONT_COLOR
		NEWLINE
		TYPE_STRING FONT_OPTIONS
		NEWLINE

		MOV AH, 01H
		INT 21H
		
		CMP AL, 1BH				;CHECKS IF ESCAPE
			JE END_OPTION
		CMP AL, 38H				;ENCODES YELLOW COLOR
			JE FONT_YELLOW		
		
		JMP CONTINUE_FONT
		
		FONT_YELLOW :
			MOV AL, 3EH
		
		CONTINUE_FONT :
		
		SUB AL, '0'
		SHL BL, 04H
		ADD AL, BL
		
		MOV OPTION_SELECT, AL
		JMP CONTINUE_OPTION
		
		END_OPTION :
			JMP ESCAPE
		
		CONTINUE_OPTION :
		
		POP BX
		POP AX
		
		RET
	
	READ_OPTIONS ENDP
	
	PROC DECREMENT	;DECREMENT THE CORRESPONDING CHARACTER
		
		PUSH AX
		PUSH SI
		
		XOR AH, AH
		MOV SI, AX	
		SUB SI, ' '
		ADD SI, SI
		DEC ASCII[SI]
		
		POP SI
		POP AX
		
		RET
		
	DECREMENT ENDP
	
CODE ENDS
END START